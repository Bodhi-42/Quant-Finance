from datetime import datetime
import numpy as np
from scipy.optimize import brentq

class Portfolio:
    def __init__(self, cf, aum):
        self.cf = cf
        self.aum = aum
        self.dates = np.array([datetime.strptime(d["date"], "%Y-%m-%d") for d in cf])
        self.flows = np.array([d["flow"] for d in cf], dtype=float)

    # ---- Time-Weighted Return (vectorized over subperiods) ----
    def twr(self, annualize=True):
        # subperiod starts/ends
        starts = np.array([self.aum[self.cf[i]["date"]] for i in range(len(self.cf)-1)], dtype=float)
        ends   = np.array([self.aum[self.cf[i+1]["date"]] for i in range(len(self.cf)-1)], dtype=float)
        flows_end = self.flows[1:]  # flow at end of each subperiod
        sub_gross = (ends - flows_end) / starts   # R_i = (V_{i+1}-CF_{i+1})/V_i
        gross = sub_gross.prod()
        if not annualize:
            return gross - 1
        total_days = (self.dates[-1] - self.dates[0]).days
        return gross**(365/total_days) - 1

    # ---- Money-Weighted Return (XIRR with irregular dates) ----
    def _xnpv(self, r):
        t0 = self.dates[0]
        years = np.array([(d - t0).days/365 for d in self.dates], dtype=float)
        cf = self.flows.copy()
        cf[-1] += self.aum[self.cf[-1]["date"]]   # add terminal market value
        return np.sum(cf / (1 + r)**years)

    def mwr(self):
        # bracket the root robustly, then solve with brentq
        lo, hi = -0.9999, 10.0
        f_lo, f_hi = self._xnpv(lo), self._xnpv(hi)
        tries = 0
        while f_lo * f_hi > 0 and tries < 25:
            hi *= 2.0
            f_hi = self._xnpv(hi)
            tries += 1
        if f_lo * f_hi > 0:
            raise RuntimeError("Could not bracket XIRR root (cash flows may not change sign).")
        return brentq(lambda r: self._xnpv(r), lo, hi, maxiter=200)
